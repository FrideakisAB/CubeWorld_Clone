{
    "fragment": "#version 440 core\n\nin vec3 FragPos;\nin vec3 Normal;\nin vec2 TexCoords;\n\nstruct DirectionLight {\n    vec4 color;\n    vec4 direction;\n};\n\nstruct PointLight {\n    vec4 positionAndIntensity;\n    vec4 colorAndRadius;\n};\n\nstruct SpotLight {\n    vec4 positionAndIntensity;\n    vec4 colorAndRadius;\n    vec4 directionAndCutterAngle;\n};\n\nstruct VisibleIndex {\n\tint index;\n};\n\nlayout(std430, binding = 0) readonly buffer LightBuffer {\n\tPointLight data[];\n} lightBuffer;\n\nlayout(std430, binding = 1) readonly buffer SpotLightBuffer {\n\tSpotLight data[];\n} spotLightBuffer;\n\nlayout(std430, binding = 2) readonly buffer VisibleLightIndicesBuffer {\n\tVisibleIndex data[];\n} visibleLightIndicesBuffer;\n\nlayout(std430, binding = 3) readonly buffer SpotVisibleLightIndicesBuffer {\n\tVisibleIndex data[];\n} spotVisibleLightIndicesBuffer;\n\nuniform DirectionLight dirLight;\nuniform vec3 color_diffuse;\nuniform vec3 viewPos;\nuniform float main_specular;\nuniform float ambient = 0.08;\nuniform int numberOfTilesX;\n\nlayout (location = 0) out vec4 fragColor;\nlayout (location = 1) out vec4 brightColor;\n\nfloat attenuate(vec3 lightDirection, float radius)\n{\n\tfloat cutoff = 0.5;\n\tfloat attenuation = dot(lightDirection, lightDirection) / (100.0 * radius);\n\tattenuation = 1.0 / (attenuation * 15.0 + 1.0);\n\tattenuation = (attenuation - cutoff) / (1.0 - cutoff);\n\n\treturn clamp(attenuation, 0.0, 1.0);\n}\n\nvoid main()\n{\n\tivec2 location = ivec2(gl_FragCoord.xy);\n\tivec2 tileID = location / ivec2(16, 16);\n\tuint index = tileID.y * numberOfTilesX + tileID.x;\n\n\tvec4 base_diffuse = vec4(color_diffuse, 1.0);\n    vec3 normal = normalize(Normal);\n\tvec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n    vec3 viewDirection = normalize(viewPos - FragPos);\n    \n    {\n\t\tvec3 lightDirection = normalize(-dirLight.direction.xyz);\n\t\tvec3 halfway = normalize(lightDirection + viewDirection);\n\n\t\tfloat diffuse = max(dot(lightDirection, normal), 0.0);\n\t\tfloat specular = pow(max(dot(normal, halfway), 0.0), 32.0);\n\n\t\tif (diffuse == 0.0)\n\t\t\tspecular = 0.0;\n\n\t\tvec3 irradiance = dirLight.color.rgb * ((base_diffuse.rgb * diffuse) + vec3(specular * main_specular));\n\t\tcolor.rgb += irradiance;\n    }\n\n\tuint offset = index * 1024;\n\tfor (uint i = 0; i < 1024 && visibleLightIndicesBuffer.data[offset + i].index != -1; ++i)\n    {\n\t\tuint lightIndex = visibleLightIndicesBuffer.data[offset + i].index;\n\t\tPointLight light = lightBuffer.data[lightIndex];\n\n\t\tvec3 lightColor = light.colorAndRadius.xyz;\n\t\tfloat lightRadius = light.colorAndRadius.w;\n\n\t\tvec3 lightDirection = light.positionAndIntensity.xyz - FragPos;\n\t\tfloat attenuation = attenuate(lightDirection, lightRadius);\n\n\t\tlightDirection = normalize(lightDirection);\n\t\tvec3 halfway = normalize(lightDirection + viewDirection);\n\n\t\tfloat diffuse = max(dot(lightDirection, normal), 0.0);\n\t\tfloat specular = pow(max(dot(normal, halfway), 0.0), 32.0);\n\n\t\tif (diffuse == 0.0)\n\t\t\tspecular = 0.0;\n\n\t\tvec3 irradiance = lightColor * ((base_diffuse.rgb * diffuse) + vec3(specular * main_specular)) * attenuation;\n\t\tcolor.rgb += irradiance;\n\t}\n    \n\tfor (uint i = 0; i < 1024 && spotVisibleLightIndicesBuffer.data[offset + i].index != -1; ++i)\n    {\n\t\tuint lightIndex = spotVisibleLightIndicesBuffer.data[offset + i].index;\n\t\tSpotLight light = spotLightBuffer.data[lightIndex];\n\n\n\t\tvec3 lightColor = light.colorAndRadius.xyz;\n\t\tfloat lightRadius = light.colorAndRadius.w;\n\n\t\tvec3 lightDirection = light.positionAndIntensity.xyz - FragPos;\n\t\tfloat attenuation = attenuate(lightDirection, lightRadius);\n\n\t\tlightDirection = normalize(lightDirection);\n\n        float theta = dot(lightDirection, normalize(-light.directionAndCutterAngle.xyz));\n        if(theta <= light.directionAndCutterAngle.w)\n            continue;\n            \n\t\tvec3 halfway = normalize(lightDirection + viewDirection);\n\n\t\tfloat diffuse = max(dot(lightDirection, normal), 0.0);\n\t\tfloat specular = pow(max(dot(normal, halfway), 0.0), 32.0);\n\n\t\tif (diffuse == 0.0)\n\t\t\tspecular = 0.0;\n\n\t\tvec3 irradiance = lightColor * ((base_diffuse.rgb * diffuse) + vec3(specular * main_specular)) * attenuation;\n\t\tcolor.rgb += irradiance;\n\t}\n\n\tcolor.rgb += base_diffuse.rgb * ambient;\n\n\tif (base_diffuse.a <= 0.2)\n\t\tdiscard;\n\t\n\tfragColor = color;\n    \n    float brightness = dot(fragColor.rgb, vec3(0.2126, 0.7152, 0.0722));\n    if(brightness > 1.0)\n        brightColor = vec4(fragColor.rgb, 1.0);\n    else\n        brightColor = vec4(0.0, 0.0, 0.0, 1.0);\n}",
    "shaderName": "LightAccumulation",
    "tag": "SHADER",
    "vertex": "#version 440 core\n\nlayout (location = 0) in vec3 aPos;\nlayout (location = 1) in vec3 aNormal;\nlayout (location = 2) in vec2 aTexCoords;\n\nuniform mat4 model;\nuniform mat4 vp;\n\nout vec3 FragPos;\nout vec3 Normal;\nout vec2 TexCoords;\n\nvoid main()\n{\n    FragPos = vec3(model * vec4(aPos, 1.0));\n    Normal = normalize(mat3(transpose(inverse(model))) * aNormal);  \n    TexCoords = aTexCoords;\n\n    gl_Position = vp * vec4(FragPos, 1.0);\n}"
}