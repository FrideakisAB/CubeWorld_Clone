{
    "fragment": "#version 440 core\n\nin vec4 FragPosLightSpace;\nin vec3 FragPos;\nin vec3 Normal;\nin vec2 TexCoords;\n\n#define HIGH_POINT_SHADOWS_COUNT 4\n#define MEDIUM_POINT_SHADOWS_COUNT 8\n#define LOW_POINT_SHADOWS_COUNT 48\n\n#define HIGH_SPOT_SHADOWS_COUNT 4\n#define MEDIUM_SPOT_SHADOWS_COUNT 8\n#define LOW_SPOT_SHADOWS_COUNT 48\n\nstruct PointShadowData {\n\tvec4 posAndFarPlane;\n};\n\nstruct SpotShadowData {\n\tvec4 posAndFarPlane;\n    vec4 directionAndCutterAngle;\n    mat4 vp;\n};\n\nlayout(std430, binding = 4) readonly buffer PointShadowDataBuffer {\n\tPointShadowData data[];\n} pointShadowData;\n\nlayout(std430, binding = 5) readonly buffer SpotShadowDataBuffer {\n\tSpotShadowData data[];\n} spotShadowData;\n\nuniform sampler2D dirShadowMap;\n\nuniform uvec3 pointShadowsCount;\nuniform samplerCubeArray pointHighShadowMap;\nuniform samplerCubeArray pointMediumShadowMap;\nuniform samplerCubeArray pointLowShadowMap;\n\nuniform uvec3 spotShadowsCount;\nuniform sampler2DArray spotHighShadowMap;\nuniform sampler2DArray spotMediumShadowMap;\nuniform sampler2DArray spotLowShadowMap;\n\nfloat DirectionalShadowCalculation(vec3 normal, vec3 fragPos, vec4 fragPosLightSpace, vec4 lightPos)\n{\n    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;\n\n    projCoords = projCoords * 0.5 + 0.5;\n\n    float closestDepth = texture(dirShadowMap, projCoords.xy).r; \n\n    float currentDepth = projCoords.z;\n\n    vec3 lightDir = normalize(lightPos.xyz - fragPos);\n    float bias = max(0.05 * (1.0 - dot(normal, lightDir)), 0.005);\n\n    float shadow = 0.0;\n    vec2 texelSize = 1.0 / textureSize(dirShadowMap, 0);\n    for(int x = -1; x <= 1; ++x)\n    {\n        for(int y = -1; y <= 1; ++y)\n        {\n            float pcfDepth = texture(dirShadowMap, projCoords.xy + vec2(x, y) * texelSize).r; \n            shadow += currentDepth - bias > pcfDepth  ? 1.0 : 0.0;        \n        }    \n    }\n    shadow /= 9.0;\n    \n    if(projCoords.z > 1.0)\n        shadow = 0.0;\n        \n    return shadow;\n}\n\nfloat PointShadowCalculation(vec3 fragPos, uint i, uint pos, samplerCubeArray arr)\n{\n    vec4 posAndFarPlane = pointShadowData.data[pos].posAndFarPlane;\n    vec3 fragToLight = fragPos - posAndFarPlane.xyz;\n    \n    float closestDepth = texture(arr, vec4(fragToLight, i)).r;\n    closestDepth *= posAndFarPlane.w;\n\n    float currentDepth = length(fragToLight);\n\n    float bias = 0.05; \n    float shadow = currentDepth -  bias > closestDepth ? 1.0 : 0.0;\n\n    return shadow;\n}\n\nfloat SpotShadowCalculation(vec3 normal, vec3 fragPos, uint i, uint pos, sampler2DArray arr)\n{\n    vec4 posAndFarPlane = spotShadowData.data[pos].posAndFarPlane;\n    vec4 fragPosLightSpace = spotShadowData.data[pos].vp * vec4(fragPos, 1.0);\n    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;\n\n    projCoords = projCoords * 0.5 + 0.5;\n\n    float closestDepth = texture(arr, vec3(projCoords.xy, i)).r;\n\n    float currentDepth = projCoords.z;\n\n    vec3 lightDir = normalize(posAndFarPlane.xyz - fragPos);\n    \n    float bias = max(0.05 * (1.0 - dot(normal, lightDir)), 0.005);\n    float shadow = currentDepth -  bias > closestDepth  ? 1.0 : 0.0;\n    \n    vec4 directionAndCutterAngle = spotShadowData.data[pos].directionAndCutterAngle;\n    float theta = dot(lightDir, normalize(-directionAndCutterAngle.xyz));\n    if(projCoords.z > 1.0 || theta <= directionAndCutterAngle.w)\n        shadow = 0.0;\n        \n    return shadow;\n}\n\nfloat CalculateShadows(vec3 normal, vec3 fragPos, vec4 fragPosLightSpace, vec4 lightPos)\n{\n    float shadow = DirectionalShadowCalculation(normal, fragPos, fragPosLightSpace, lightPos);\n    for (uint i = 0; i < pointShadowsCount.x; ++i)\n        shadow += PointShadowCalculation(fragPos, i, i, pointHighShadowMap);\n    for (uint i = 0; i < pointShadowsCount.y; ++i)\n        shadow += PointShadowCalculation(fragPos, i, pointShadowsCount.x + i, pointMediumShadowMap);\n    for (uint i = 0; i < pointShadowsCount.z; ++i)\n        shadow += PointShadowCalculation(fragPos, i, pointShadowsCount.x + pointShadowsCount.y + i, pointLowShadowMap);\n    for (uint i = 0; i < spotShadowsCount.x; ++i)\n        shadow += SpotShadowCalculation(normal, fragPos, i, i, spotHighShadowMap);\n    for (uint i = 0; i < spotShadowsCount.y; ++i)\n        shadow += SpotShadowCalculation(normal, fragPos, i, spotShadowsCount.x + i, spotMediumShadowMap);\n    for (uint i = 0; i < spotShadowsCount.z; ++i)\n        shadow += SpotShadowCalculation(normal, fragPos, i, spotShadowsCount.x + spotShadowsCount.y + i, spotLowShadowMap);\n        \n    return shadow;\n}\n\n\nstruct DirectionLight {\n    vec4 position;\n    vec4 color;\n    vec4 direction;\n};\n\nstruct PointLight {\n    vec4 positionAndIntensity;\n    vec4 colorAndRadius;\n};\n\nstruct SpotLight {\n    vec4 positionAndIntensity;\n    vec4 colorAndRadius;\n    vec4 directionAndCutterAngle;\n};\n\nstruct VisibleIndex {\n\tint index;\n};\n\nlayout(std430, binding = 0) readonly buffer LightBuffer {\n\tPointLight data[];\n} lightBuffer;\n\nlayout(std430, binding = 1) readonly buffer SpotLightBuffer {\n\tSpotLight data[];\n} spotLightBuffer;\n\nlayout(std430, binding = 2) readonly buffer VisibleLightIndicesBuffer {\n\tVisibleIndex data[];\n} visibleLightIndicesBuffer;\n\nlayout(std430, binding = 3) readonly buffer SpotVisibleLightIndicesBuffer {\n\tVisibleIndex data[];\n} spotVisibleLightIndicesBuffer;\n\nuniform DirectionLight dirLight;\n\nuniform vec3 color_diffuse;\nuniform vec3 viewPos;\nuniform float main_specular;\nuniform float ambient = 0.08;\nuniform int numberOfTilesX;\n\nlayout (location = 0) out vec4 fragColor;\nlayout (location = 1) out vec4 brightColor;\n\nfloat attenuate(vec3 lightDirection, float radius)\n{\n\tfloat cutoff = 0.5;\n\tfloat attenuation = dot(lightDirection, lightDirection) / (100.0 * radius);\n\tattenuation = 1.0 / (attenuation * 15.0 + 1.0);\n\tattenuation = (attenuation - cutoff) / (1.0 - cutoff);\n\n\treturn clamp(attenuation, 0.0, 1.0);\n}\n\nvoid main()\n{\n\tivec2 location = ivec2(gl_FragCoord.xy);\n\tivec2 tileID = location / ivec2(16, 16);\n\tuint index = tileID.y * numberOfTilesX + tileID.x;\n\n\tvec4 base_diffuse = vec4(color_diffuse, 1.0);\n    vec3 normal = normalize(Normal);\n\tvec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n    vec3 viewDirection = normalize(viewPos - FragPos);\n    \n    {\n\t\tvec3 lightDirection = normalize(-dirLight.direction.xyz);\n\t\tvec3 halfway = normalize(lightDirection + viewDirection);\n\n\t\tfloat diffuse = max(dot(lightDirection, normal), 0.0);\n\t\tfloat specular = pow(max(dot(normal, halfway), 0.0), 32.0);\n\n\t\tif (diffuse == 0.0)\n\t\t\tspecular = 0.0;\n\n\t\tvec3 irradiance = dirLight.color.rgb * ((base_diffuse.rgb * diffuse) + vec3(specular * main_specular)) * dirLight.color.w;\n\t\tcolor.rgb += irradiance;\n    }\n\n\tuint offset = index * 1024;\n\tfor (uint i = 0; i < 1024 && visibleLightIndicesBuffer.data[offset + i].index != -1; ++i)\n    {\n\t\tuint lightIndex = visibleLightIndicesBuffer.data[offset + i].index;\n\t\tPointLight light = lightBuffer.data[lightIndex];\n\n\t\tvec3 lightColor = light.colorAndRadius.xyz;\n\t\tfloat lightRadius = light.colorAndRadius.w;\n\n\t\tvec3 lightDirection = light.positionAndIntensity.xyz - FragPos;\n\t\tfloat attenuation = attenuate(lightDirection, lightRadius);\n\n\t\tlightDirection = normalize(lightDirection);\n\t\tvec3 halfway = normalize(lightDirection + viewDirection);\n\n\t\tfloat diffuse = max(dot(lightDirection, normal), 0.0);\n\t\tfloat specular = pow(max(dot(normal, halfway), 0.0), 32.0);\n\n\t\tif (diffuse == 0.0)\n\t\t\tspecular = 0.0;\n\n\t\tvec3 irradiance = lightColor * ((base_diffuse.rgb * diffuse) + vec3(specular * main_specular)) * attenuation;\n\t\tcolor.rgb += irradiance;\n\t}\n    \n\tfor (uint i = 0; i < 1024 && spotVisibleLightIndicesBuffer.data[offset + i].index != -1; ++i)\n    {\n\t\tuint lightIndex = spotVisibleLightIndicesBuffer.data[offset + i].index;\n\t\tSpotLight light = spotLightBuffer.data[lightIndex];\n\n\n\t\tvec3 lightColor = light.colorAndRadius.xyz;\n\t\tfloat lightRadius = light.colorAndRadius.w;\n\n\t\tvec3 lightDirection = light.positionAndIntensity.xyz - FragPos;\n\t\tfloat attenuation = attenuate(lightDirection, lightRadius);\n\n\t\tlightDirection = normalize(lightDirection);\n\n        float theta = dot(lightDirection, normalize(-light.directionAndCutterAngle.xyz));\n        if(theta <= light.directionAndCutterAngle.w)\n            continue;\n            \n\t\tvec3 halfway = normalize(lightDirection + viewDirection);\n\n\t\tfloat diffuse = max(dot(lightDirection, normal), 0.0);\n\t\tfloat specular = pow(max(dot(normal, halfway), 0.0), 32.0);\n\n\t\tif (diffuse == 0.0)\n\t\t\tspecular = 0.0;\n\n\t\tvec3 irradiance = lightColor * ((base_diffuse.rgb * diffuse) + vec3(specular * main_specular)) * attenuation;\n\t\tcolor.rgb += irradiance;\n\t}\n        \n    float shadow = CalculateShadows(normal, FragPos, FragPosLightSpace, dirLight.position);\n    \n    color.rgb = (1.0 - shadow) * color.rgb;\n\tcolor.rgb += base_diffuse.rgb * ambient;\n\n\tif (base_diffuse.a <= 0.2)\n\t\tdiscard;\n\t\n\tfragColor = color;\n    \n    float brightness = dot(fragColor.rgb, vec3(0.2126, 0.7152, 0.0722));\n    if(brightness > 1.0)\n        brightColor = vec4(fragColor.rgb, 1.0);\n    else\n        brightColor = vec4(0.0, 0.0, 0.0, 1.0);\n}",
    "shaderName": "LightAccumulation",
    "tag": "SHADER",
    "vertex": "#version 440 core\n\nlayout (location = 0) in vec3 aPos;\nlayout (location = 1) in vec3 aNormal;\nlayout (location = 2) in vec2 aTexCoords;\n\nuniform mat4 model;\nuniform mat4 vp;\nuniform mat4 lightSpaceMatrix;\n\nout vec4 FragPosLightSpace;\nout vec3 FragPos;\nout vec3 Normal;\nout vec2 TexCoords;\n\nvoid main()\n{\n    FragPos = vec3(model * vec4(aPos, 1.0));\n    Normal = normalize(mat3(transpose(inverse(model))) * aNormal);  \n    TexCoords = aTexCoords;\n    FragPosLightSpace = lightSpaceMatrix * vec4(FragPos, 1.0);\n\n    gl_Position = vp * vec4(FragPos, 1.0);\n}"
}