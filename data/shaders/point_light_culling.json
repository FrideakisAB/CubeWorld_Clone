{
    "compute": "#version 440 core\n\nstruct PointLight {\n    vec4 positionAndIntensity;\n    vec4 colorAndRadius;\n};\n\nstruct VisibleIndex {\n    int index;\n};\n\nlayout(std430, binding = 0) readonly buffer LightBuffer {\n    PointLight data[];\n} lightBuffer;\n\nlayout(std430, binding = 1) writeonly buffer VisibleLightIndicesBuffer {\n    VisibleIndex data[];\n} visibleLightIndicesBuffer;\n\nuniform sampler2D depthMap;\nuniform mat4 view;\nuniform mat4 projection;\nuniform ivec2 screenSize;\nuniform int lightCount;\n\nshared uint minDepthInt;\nshared uint maxDepthInt;\nshared uint visibleLightCount;\nshared vec4 frustumPlanes[6];\nshared int visibleLightIndices[1024];\nshared mat4 viewProjection;\n\n#define TILE_SIZE 16\nlayout(local_size_x = TILE_SIZE, local_size_y = TILE_SIZE, local_size_z = 1) in;\nvoid main()\n{\n    ivec2 location = ivec2(gl_GlobalInvocationID.xy);\n    ivec2 itemID = ivec2(gl_LocalInvocationID.xy);\n    ivec2 tileID = ivec2(gl_WorkGroupID.xy);\n    ivec2 tileNumber = ivec2(gl_NumWorkGroups.xy);\n    uint index = tileID.y * tileNumber.x + tileID.x;\n\n    if (gl_LocalInvocationIndex == 0)\n    {\n        minDepthInt = 0xFFFFFFFF;\n        maxDepthInt = 0;\n        visibleLightCount = 0;\n        viewProjection = projection * view;\n    }\n\n    barrier();\n\n    float maxDepth, minDepth;\n    vec2 text = vec2(location) / screenSize;\n    float depth = texture(depthMap, text).r;\n    depth = (0.5 * projection[3][2]) / (depth + 0.5 * projection[2][2] - 0.5);\n\n    uint depthInt = floatBitsToUint(depth);\n    atomicMin(minDepthInt, depthInt);\n    atomicMax(maxDepthInt, depthInt);\n\n    barrier();\n\n    if (gl_LocalInvocationIndex == 0)\n    {\n        minDepth = uintBitsToFloat(minDepthInt);\n        maxDepth = uintBitsToFloat(maxDepthInt);\n\n        vec2 negativeStep = (2.0 * vec2(tileID)) / vec2(tileNumber);\n        vec2 positiveStep = (2.0 * vec2(tileID + ivec2(1, 1))) / vec2(tileNumber);\n\n        frustumPlanes[0] = vec4(1.0, 0.0, 0.0, 1.0 - negativeStep.x); // Left\n        frustumPlanes[1] = vec4(-1.0, 0.0, 0.0, -1.0 + positiveStep.x); // Right\n        frustumPlanes[2] = vec4(0.0, 1.0, 0.0, 1.0 - negativeStep.y); // Bottom\n        frustumPlanes[3] = vec4(0.0, -1.0, 0.0, -1.0 + positiveStep.y); // Top\n        frustumPlanes[4] = vec4(0.0, 0.0, -1.0, -minDepth); // Near\n        frustumPlanes[5] = vec4(0.0, 0.0, 1.0, maxDepth); // Far\n\n        for (uint i = 0; i < 4; ++i)\n        {\n            frustumPlanes[i] *= viewProjection;\n            frustumPlanes[i] /= length(frustumPlanes[i].xyz);\n\t\t}\n\n        frustumPlanes[4] *= view;\n        frustumPlanes[4] /= length(frustumPlanes[4].xyz);\n        frustumPlanes[5] *= view;\n        frustumPlanes[5] /= length(frustumPlanes[5].xyz);\n    }\n\n    barrier();\n\n    uint threadCount = TILE_SIZE * TILE_SIZE;\n    uint passCount = (lightCount + threadCount - 1) / threadCount;\n    for (uint i = 0; i < passCount; ++i)\n    {\n        uint lightIndex = i * threadCount + gl_LocalInvocationIndex;\n        if (lightIndex >= lightCount)\n            break;\n\n        vec4 position = vec4(lightBuffer.data[lightIndex].positionAndIntensity.xyz, 1.0);\n        float radius = lightBuffer.data[lightIndex].colorAndRadius.w;\n\n        float distance = 0.0;\n        for (uint j = 0; j < 6; ++j)\n        {\n            distance = dot(position, frustumPlanes[j]) + radius;\n\n            if (distance <= 0.0)\n                break;\n        }\n\n        if (distance > 0.0)\n        {\n            uint offset = atomicAdd(visibleLightCount, 1);\n            visibleLightIndices[offset] = int(lightIndex);\n        }\n    }\n\n    barrier();\n\n    if (gl_LocalInvocationIndex == 0)\n    {\n        uint offset = index * 1024;\n        for (uint i = 0; i < visibleLightCount; ++i)\n            visibleLightIndicesBuffer.data[offset + i].index = visibleLightIndices[i];\n\n        if (visibleLightCount != 1024)\n            visibleLightIndicesBuffer.data[offset + visibleLightCount].index = -1;\n    }\n}",
    "shaderName": "PointLightCulling",
    "tag": "SHADER"
}